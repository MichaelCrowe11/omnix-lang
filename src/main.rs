use clap::{Parser, Subcommand};
use std::path::PathBuf;
use anyhow::Result;

#[derive(Parser)]
#[command(name = "omnix")]
#[command(about = "OMNIX distributed consensus programming language")]
#[command(version = "0.1.0")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Compile OMNIX source code
    Compile {
        /// Input file to compile
        #[arg(short, long)]
        input: PathBuf,
        
        /// Output file (optional)
        #[arg(short, long)]
        output: Option<PathBuf>,
        
        /// Enable verbose output
        #[arg(short, long)]
        verbose: bool,
    },
    
    /// Run OMNIX program
    Run {
        /// Input file to run
        #[arg(short, long)]
        input: PathBuf,
        
        /// Node ID for this instance
        #[arg(long, default_value = "node1")]
        node_id: String,
        
        /// Network port
        #[arg(long, default_value = "8080")]
        port: u16,
        
        /// Enable verbose output
        #[arg(short, long)]
        verbose: bool,
    },
    
    /// Initialize new OMNIX project
    Init {
        /// Project name
        name: String,
        
        /// Project directory (optional)
        #[arg(short, long)]
        path: Option<PathBuf>,
    },
    
    /// Check syntax of OMNIX code
    Check {
        /// Input file to check
        #[arg(short, long)]
        input: PathBuf,
    },
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();
    
    match cli.command {
        Commands::Compile { input, output, verbose } => {
            compile_file(input, output, verbose).await
        }
        Commands::Run { input, node_id, port, verbose } => {
            run_file(input, node_id, port, verbose).await
        }
        Commands::Init { name, path } => {
            init_project(name, path).await
        }
        Commands::Check { input } => {
            check_file(input).await
        }
    }
}

async fn compile_file(input: PathBuf, output: Option<PathBuf>, verbose: bool) -> Result<()> {
    if verbose {
        println!("Compiling OMNIX file: {}", input.display());
    }
    
    let source = std::fs::read_to_string(&input)?;
    
    // Parse the source code
    let mut lexer = omnix_compiler::Lexer::new(&source);
    let mut parser = omnix_compiler::Parser::new(&mut lexer);
    let ast = parser.parse()?;
    
    if verbose {
        println!("Successfully parsed {} nodes", ast.len());
    }
    
    // Generate output path if not provided
    let output_path = output.unwrap_or_else(|| {
        let mut path = input.clone();
        path.set_extension("omx.json");
        path
    });
    
    // Serialize AST to JSON
    let json = serde_json::to_string_pretty(&ast)?;
    std::fs::write(&output_path, json)?;
    
    println!("Compiled to: {}", output_path.display());
    Ok(())
}

async fn run_file(input: PathBuf, node_id: String, port: u16, verbose: bool) -> Result<()> {
    if verbose {
        println!("Running OMNIX file: {}", input.display());
        println!("Node ID: {}, Port: {}", node_id, port);
    }
    
    let source = std::fs::read_to_string(&input)?;
    
    // Parse the source code
    let mut lexer = omnix_compiler::Lexer::new(&source);
    let mut parser = omnix_compiler::Parser::new(&mut lexer);
    let ast = parser.parse()?;
    
    // Create runtime environment
    let config = omnix_runtime::NetworkConfig {
        port,
        discovery: omnix_runtime::DiscoveryMethod::MDNS,
    };
    
    let mut runtime = omnix_runtime::Runtime::new(node_id, config)?;
    
    // Execute the program
    runtime.execute(ast).await?;
    
    // Keep running until interrupted
    println!("OMNIX node started. Press Ctrl+C to stop.");
    tokio::signal::ctrl_c().await?;
    println!("Shutting down...");
    
    Ok(())
}

async fn init_project(name: String, path: Option<PathBuf>) -> Result<()> {
    let project_path = path.unwrap_or_else(|| PathBuf::from(&name));
    
    // Create project directory
    std::fs::create_dir_all(&project_path)?;
    
    // Create main.omx file
    let main_content = format!(r#"// {} - OMNIX Distributed Application
// Generated by OMNIX CLI

@network(port: 8080, discovery: mDNS)
node {}Node {{
    @replicated
    state counter: u64 = 0;
    
    function increment() {{
        let proposal = counter + 1;
        let result = proposal <!> {{
            validators: 3,
            timeout: 3000ms,
            algorithm: Consensus::Raft
        }};
        
        when result.accepted() {{
            counter <#> result.value;
            broadcast(CounterUpdate(counter));
        }}
    }}
    
    @rpc
    function get_value() -> u64 {{
        return counter;
    }}
}}

function main() {{
    let node = {}Node::new();
    node.start();
    node.join_cluster("{}-cluster");
    
    println("Node {{}} started", node.id);
}}
"#, name, name, name, name);
    
    let main_file = project_path.join("main.omx");
    std::fs::write(main_file, main_content)?;
    
    // Create Cargo.toml
    let cargo_content = format!(r#"[package]
name = "{}"
version = "0.1.0"
edition = "2021"

[dependencies]
omnix-runtime = {{ path = "../omnix-lang/runtime" }}
omnix-compiler = {{ path = "../omnix-lang/compiler" }}
tokio = {{ version = "1.0", features = ["full"] }}
anyhow = "1.0"
"#, name);
    
    let cargo_file = project_path.join("Cargo.toml");
    std::fs::write(cargo_file, cargo_content)?;
    
    // Create README.md
    let readme_content = format!(r#"# {}

A distributed application built with OMNIX.

## Usage

```bash
# Run the application
omnix run -i main.omx --node-id node1 --port 8080

# In another terminal, run another node
omnix run -i main.omx --node-id node2 --port 8081
```

## Features

- Distributed consensus using Raft algorithm
- Replicated state management
- Automatic peer discovery
- Byzantine fault tolerance
"#, name);
    
    let readme_file = project_path.join("README.md");
    std::fs::write(readme_file, readme_content)?;
    
    println!("Created OMNIX project: {}", project_path.display());
    println!("Run 'omnix run -i main.omx' to start the application");
    
    Ok(())
}

async fn check_file(input: PathBuf) -> Result<()> {
    println!("Checking OMNIX file: {}", input.display());
    
    let source = std::fs::read_to_string(&input)?;
    
    // Parse the source code
    let mut lexer = omnix_compiler::Lexer::new(&source);
    let mut parser = omnix_compiler::Parser::new(&mut lexer);
    
    match parser.parse() {
        Ok(ast) => {
            println!("✓ Syntax is valid");
            println!("✓ Found {} top-level definitions", ast.len());
            
            // Basic semantic checks
            for item in &ast {
                match item {
                    omnix_compiler::ASTNode::NodeDefinition(node) => {
                        println!("✓ Node '{}' with {} methods", node.name, node.methods.len());
                    }
                    omnix_compiler::ASTNode::ConsensusCluster(cluster) => {
                        println!("✓ Consensus cluster '{}' with {} replicas", cluster.name, cluster.replicas);
                    }
                    _ => {}
                }
            }
        }
        Err(e) => {
            println!("✗ Syntax error: {}", e);
            return Err(e);
        }
    }
    
    Ok(())
}