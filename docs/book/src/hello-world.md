# Hello, Distributed World!

Welcome to your first OMNIX program! In this tutorial, we'll build a simple distributed counter that demonstrates the core concepts of consensus-based programming.

## Creating a New Project

First, let's create a new OMNIX project:

```bash
omnix init counter-demo
cd counter-demo
```

This creates a directory structure:

```
counter-demo/
â”œâ”€â”€ main.omx          # Main application file
â”œâ”€â”€ Cargo.toml        # Project metadata
â””â”€â”€ README.md         # Project documentation
```

## Your First OMNIX Program

Let's examine the generated `main.omx`:

```omx
// counter-demo - OMNIX Distributed Application
// Generated by OMNIX CLI

@network(port: 8080, discovery: mDNS)
node CounterNode {
    @replicated
    state counter: u64 = 0;
    
    function increment() {
        let proposal = counter + 1;
        let result = proposal <!> {
            validators: 3,
            timeout: 3000ms,
            algorithm: Consensus::Raft
        };
        
        when result.accepted() {
            counter <#> result.value;
            broadcast(CounterUpdate(counter));
        }
    }
    
    @rpc
    function get_value() -> u64 {
        return counter;
    }
}

function main() {
    let node = CounterNode::new();
    node.start();
    node.join_cluster("counter-cluster");
    
    println("Node {} started", node.id);
}
```

## Understanding the Code

Let's break down what's happening:

### 1. Node Definition

```omx
@network(port: 8080, discovery: mDNS)
node CounterNode {
    // ...
}
```

- `@network` annotation configures networking (port 8080, mDNS discovery)
- `node` defines a distributed computing node
- Nodes can communicate with peers automatically

### 2. Replicated State

```omx
@replicated
state counter: u64 = 0;
```

- `@replicated` annotation marks state as distributed
- State is automatically synchronized across all nodes
- Type `u64` is a 64-bit unsigned integer

### 3. Consensus Proposal

```omx
let result = proposal <!> {
    validators: 3,
    timeout: 3000ms,
    algorithm: Consensus::Raft
};
```

- `<!>` is the **propose operator**
- Submits a value to the consensus algorithm
- Configuration specifies validators, timeout, and algorithm

### 4. State Merge

```omx
when result.accepted() {
    counter <#> result.value;
}
```

- `when` executes code if condition is true
- `<#>` is the **merge operator**
- Safely updates replicated state after consensus

## Running the Program

### Step 1: Check Syntax

First, verify your code is correct:

```bash
omnix check -i main.omx
```

Expected output:
```
Checking OMNIX file: main.omx
âœ“ Lexical analysis successful (45 tokens)
âœ“ Syntax is valid
âœ“ Found 2 top-level definitions
âœ“ Node 'CounterNode' with 2 items
âœ“ Function 'main' with 0 parameters
```

### Step 2: Compile

Compile to check for any semantic errors:

```bash
omnix compile -i main.omx -v
```

Expected output:
```
Compiling OMNIX file: main.omx
Successfully parsed 2 top-level items
Compiled to: main.omx.json
```

### Step 3: Run Single Node

Start your first node:

```bash
omnix run -i main.omx --node-id node1 --port 8080 -v
```

Expected output:
```
Running OMNIX file: main.omx
Node ID: node1, Port: 8080
Successfully parsed 2 top-level items
Executing node: CounterNode
Initialized state variable: counter = UInteger(0)
Registered function: increment
Registered function: get_value
Executing function: main
OMNIX node started. Press Ctrl+C to stop.
```

### Step 4: Run Multiple Nodes

Open additional terminals and run more nodes:

```bash
# Terminal 2
omnix run -i main.omx --node-id node2 --port 8081

# Terminal 3
omnix run -i main.omx --node-id node3 --port 8082
```

You now have a 3-node distributed system!

## Interactive Testing

Let's extend our program to demonstrate consensus in action:

```omx
// Add this function to CounterNode
function demo() {
    println("Starting consensus demo...");
    
    // Propose increments
    increment();
    increment();
    increment();
    
    let final_value = get_value();
    println("Final counter value: {}", final_value);
}
```

Update the main function:

```omx
function main() {
    let node = CounterNode::new();
    node.start();
    node.join_cluster("counter-cluster");
    
    println("Node {} started", node.id);
    
    // Run demo after startup
    node.demo();
}
```

## What Just Happened?

Congratulations! You've just:

1. **Created** a distributed node with replicated state
2. **Implemented** consensus-based state updates
3. **Ran** a multi-node distributed system
4. **Demonstrated** fault-tolerant consensus

The OMNIX runtime automatically handled:
- âœ… Peer discovery via mDNS
- âœ… Leader election using Raft
- âœ… State replication across nodes
- âœ… Network failure detection
- âœ… Consensus protocol execution

## Key Concepts Learned

| Concept | OMNIX Feature | Purpose |
|---------|---------------|---------|
| **Distributed State** | `@replicated state` | Shared state across nodes |
| **Consensus** | `value <!> { ... }` | Propose values for agreement |
| **State Update** | `state <#> value` | Safely merge consensus results |
| **Networking** | `@network` | Automatic peer discovery |
| **Fault Tolerance** | Raft algorithm | Handle node failures |

## Next Steps

Now that you understand the basics, let's explore:

â†’ [Your First Consensus](./first-consensus.md) - Deep dive into consensus operators  
â†’ [Language Overview](./language/overview.md) - Complete language tour  
â†’ [Examples](./examples/counter.md) - More advanced distributed systems  

## Common Patterns

Here are some patterns you'll use frequently:

### Safe Increment Pattern
```omx
function safe_increment() {
    let new_value = counter + 1;
    let result = new_value <!> { validators: majority() };
    when result.accepted() {
        counter <#> result.value;
    }
}
```

### Conditional Consensus
```omx
function conditional_update(condition: bool, value: u64) {
    when condition {
        let result = value <!> { timeout: 5000ms };
        when result.accepted() {
            state <#> result.value;
        }
    }
}
```

### Multi-Value Consensus
```omx
function batch_update(values: Vec<u64>) {
    let proposal = BatchUpdate { values };
    let result = proposal <!> { quorum: 2*f + 1 };
    when result.committed() {
        for value in result.values {
            state <#> value;
        }
    }
}
```

Welcome to distributed programming with OMNIX! ðŸŽ‰